| # 颜色：奇黄偶蓝                                             |
| ------------------------------------------------------------ |
| ## 1. list[::]注意切割时候会生成新的list，所以新的list会有新的index<br /><br />[1/167. Two Sum II - Input array is sorted](onenote:Data_str\Array_String.one#1\167. Two Sum II - Input array is sorted&section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&page-id={5121938F-EAD0-4B08-8AD4-CC2EBA249BFD}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode)        [1.    Two Sum](onenote:Data_str\Array_String.one#1\167. Two Sum II - Input array is sorted&section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&page-id={5121938F-EAD0-4B08-8AD4-CC2EBA249BFD}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode) <br /> |
| ## 3. 滑动窗口题目<br />[3. Longest Substring Without Repeating Characters](onenote:interview_mediun.one#3. Longest Substring Without Repeating Characters&section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&page-id={D3DA2123-E8EC-4DCB-B111-EF8A0D272929}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode)   <br /><br /> |
| ## 19. 要是倒序删除某个值，可以使用一快一慢指针，让快指针先跑n个长度，在启用慢指针，这样快指针到达终点时，与慢指针刚好相差n个长度>><br /><br /><br />19. 删除链表的倒数第N个节点        判断**linklist长度是偶数还是奇数：主要看fast，如果fast是None的话，链表的长度是偶数，所以判断的时候用if** not    fast : (linklist length example#123456)19. 删除链表的倒数第N个节点 |
|                                                              |
| >>>从list后面开始比较，这样的好处是前面排过序的部分不用反复排序                  [88. Merge Sorted Array](onenote:Data_str\Sort_and_Search.one#88. Merge Sorted Array&section-id={0B4DFBAC-DF29-4843-88F3-0BDC6A6E4922}&page-id={8DAD90C3-74DA-4A8C-9656-F28E63655F37}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/leetcoding)             ![Input :  numsl =  nums2 =  Output :  nCA  [2,5, 6  [1,2, 2,  s  3,5, 6] ](file:///C:/Users/RobotLiu/AppData/Local/Packages/Microsoft.Office.OneNote_8wekyb3d8bbwe/TempState/msohtmlclip/clip_image002.png) |
| **queue****使用****/BFS****>>**[102.(层级遍历)Level Order Traversal](onenote:leetcode.one#102.(层级遍历)Level Order Traversal&section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&page-id={13B3C18E-0A82-453C-ABFD-3869DABB68F1}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer)        **需要总结：** |
| 初始化定义ans的方式def __init__(self):>>[104. Maximum Depth of Binary Tree](onenote:leetcode.one#104. Maximum Depth of Binary Tree&section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&page-id={62C0D1BB-2FE2-4127-B786-EBD752CEDB66}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer) |
| a =         1 if 0 else 2使用结构>>[160. 相交链表](onenote:leetcode.one#160. 相交链表&section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&page-id={A80F61AB-34A7-48AE-A186-EC72B11C8669}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer)        逻辑解读：        if 0 :         a = 1    else:          a =2 |
| 让数字在一定范围内循环递增常常使用         % 操作                   [189. Rotate Array](https://leetcode.com/problems/rotate-array/)        注意点：当循环在一个list中，比如list=[1,2,3,4]，当寻找index=5时，希望循环list里面的元素，使用index = index  %  len(list)         来自 <[https://github.com/cy69855522/Shortest-LeetCode-Python-Solutions/blob/master/README.md#-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE](https://github.com/cy69855522/Shortest-LeetCode-Python-Solutions/blob/master/README.md#-二分查找)> |
| 创造dummy节点以满足整体性dummy_head         = ListNode(-1)[203. Remove Linked List Elements](onenote:leetcode.one#203. Remove Linked List Elements&section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&page-id={D5088368-2685-4015-BE04-8456FCEF504C}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer) |
| [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)        像这一类的重复问题的查找，基本上是有两种思路：--使用hash性质的set/dict，--或者使用异或的数学解决 |
| [283. 移动零](onenote:Data_str\Array_String.one#283. 移动零&section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&page-id={47AA3E93-247F-453F-BECA-AC86CE176950}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode)                  [283.Move Zeroes](https://leetcode.com/problems/move-zeroes/)           交换两个值的时候a，b = b，a      while循环的中断点需要加break |
| [412.         Fizz Buzz](https://leetcode.com/problems/fizz-buzz/)>>>来自 <<https://leetcode.com/problems/fizz-buzz/>>                 利用字典存储对应的值，但是要想两个字典进行融合输出    fizz_buzz_dict = {3 : "Fizz", 5 : "Buzz"}  >>>想要输出3/5的组合即15 = 3*5使用对字典循环    num_ans_str =    ""        for key in fizz_buzz_dict.keys():             # If the num is divisible by key,             # then add the corresponding string    mapping to current num_ans_str             if num % key == 0:                 num_ans_str += fizz_buzz_dict[key]  # 其实这个地方3/5分两部分进行添加 |
| set操作时间空间都是O(1)                  [349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/)        来自 <<https://leetcode.com/problems/intersection-of-two-arrays/solution/>>         To solve the problem in         linear time, let's use the structure set, which provides in/contains operation in O(1) time in average case.             list(set2         & set1)查找出公共元素             list转化为set都需要O(n)的空间             Complexity         Analysis        Time complexity : O(n+m), where n and m are arrays' lengths.O(n) time is used to convert nums1into set,O(m) time    is used to convert nums2, and contains/in operations are O(1) in the average case.    Space complexity : O(m+n) in the worst case when all elements in the    arrays are different. |
| [412.         Fizz Buzz](https://leetcode.com/problems/fizz-buzz/)>>>来自 <<https://leetcode.com/problems/fizz-buzz/>>                 利用字典存储对应的值，但是要想两个字典进行融合输出    fizz_buzz_dict = {3 : "Fizz", 5 : "Buzz"}  >>>想要输出3/5的组合即15 = 3*5使用对字典循环    num_ans_str =    ""        for key in fizz_buzz_dict.keys():             # If the num is divisible by key,             # then add the corresponding string    mapping to current num_ans_str             if num % key == 0:                 num_ans_str += fizz_buzz_dict[key]  # 其实这个地方3/5分两部分进行添加 |
| 判断单词的大小写                  520. Detect Capital[520. Detect Capital](onenote:Data_str\Array_String.one#520. Detect Capital&section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&page-id={C3D8481C-1B74-4F14-B5C0-64C6EDA58ABC}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode)           对所有单词判断大写all('A'          <= ch <= 'Z' for ch in word)      对每个单词进行标记             c    = 0        for i in word:            if i == i.upper():               c += 1        return c == len(word) or (c == 1 and    word[0] == word[0].upper()) or c == 0 |
| **使用****and****去掉root** **= None****的情况**        **stack = root and [root]****>>** [590. N-ary Tree    Postorder Traversal](onenote:leetcode.one#590. N-ary Tree Postorder Traversal&section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&page-id={8185AAC5-81FF-47E0-ACDF-5DE3B7632B55}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer)**>>**[700. Search in    a Binary Search Tree](onenote:leetcode.one#700. Search in a Binary Search Tree&section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&page-id={295CA6D0-329D-4A89-BF02-14CCB888BE7E}&end&base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer) |
|                                                              |