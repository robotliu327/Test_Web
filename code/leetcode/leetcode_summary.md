<!-- wp:table {"backgroundColor":"subtle-pale-green","align":"center","className":"is-style-stripes"} -->

<table class="wp-block-table aligncenter has-subtle-pale-green-background-color has-background is-style-stripes"><tbody><tr><td> <a href="https://leetcode.com/">L</a><a href="https://leetcode.com/problemset/all/" target="_blank" rel="noreferrer noopener" aria-label="（在新窗口打开）">eetCode - The World's Leading Online Programming Learning Platform </a></td></tr><tr><td>  <a href="onenote:Data_str\Array_String.one#1\167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted&amp;section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&amp;page-id={5121938F-EAD0-4B08-8AD4-CC2EBA249BFD}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">1.    Two Sum</a> <br> list[::]注意切割时候会生成新的list，所以新的list会有新的index<br> <a href="onenote:Data_str\Array_String.one#1\167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted&amp;section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&amp;page-id={5121938F-EAD0-4B08-8AD4-CC2EBA249BFD}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">1/167. Two Sum II - Input array is sorted</a>      </td></tr><tr><td><a href="onenote:interview_mediun.one#2.%C2%A0Add%20Two%20Numbers&amp;section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&amp;page-id={EC3CCB26-6D17-4D4B-A979-2FF85A1070B3}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">2. Add Two    Numbers</a>  Add Two Numbers       <br>1.没想到只要检测到为None可使用数值0去取代，<code>x = l1.val if l1 else 0</code>妙呀    2.carry进位使用的顺序问题，其实一开始我想用，但是不知道如何下手      </td></tr><tr><td> <a href="onenote:interview_mediun.one#3.%C2%A0Longest%20Substring%20Without%20Repeating%20Characters&amp;section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&amp;page-id={D3DA2123-E8EC-4DCB-B111-EF8A0D272929}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">3. Longest Substring Without Repeating Characters</a>   <br>滑动窗口题目：比较经典的流程和二分法有点相似                   <br> <code>cache = {}<br> while l&lt;length and r &lt;length:<br>    if s[r] not in cache:<br>       cache[s[r]] = r<br>       r += 1<br>    else:<br>       longest = max(longest , r-l)<br>       cache.pop(s[l])<br>       l += 1 </code></td></tr><tr><td>  <a href="onenote:interview_mediun.one#5.%C2%A0Longest%20Palindromic%20Substring&amp;section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&amp;page-id={DD4455B4-91D0-41C3-9D8A-DD97ECB261CE}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">5. Longest    Palindromic Substring</a>                       <br> 想法1：在使用配对的时候，可以尝试使用从中间两边去扩充，但是需要考虑长度是奇偶的问题        想法2：寻找最大的回文串，指针一前一后去寻找的话，第一次找到就是最长的  </td></tr><tr><td> <a href="onenote:interview_easy.one#7.%C2%A0Reverse%20Integer&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={89BFAA1B-62DC-4385-AAB6-0498A9146114}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">7. Reverse Integer</a>              <br>实现数字的反转，需要好好记住<br>  <code># 实现反转 <br> result = 0<br> while x:<br>     temp = result * 10 + x % 10<br>     if temp//10 != result:<br>         return 0<br>     result = temp<br>     x //= 10    </code></td></tr><tr><td> <a href="onenote:interview_mediun.one#15.%C2%A03Sum&amp;section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&amp;page-id={7D9C780E-9009-47DC-B563-D6CA854F1272}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">15. 3Sum</a>               <br>解决思路：先升序排列（和为0只能从两头取一正一负）后使用双指针即可            </td></tr><tr><td> <a href="onenote:Data_str\Link_list.one#19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9&amp;section-id={3921D34D-4622-49A8-921B-61CF13EF4CAD}&amp;page-id={8AB3ADE7-CCA7-4400-A2C1-E3ADC242359E}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">19. 删除链表的倒数第N个节点</a>》》<a href="onenote:Data_str\Link_list.one#19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9&amp;section-id={3921D34D-4622-49A8-921B-61CF13EF4CAD}&amp;page-id={8AB3ADE7-CCA7-4400-A2C1-E3ADC242359E}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">19. 删除链表的倒数第N个节点</a> <br>要是倒序删除某个值，可以使用一快一慢指针，让快指针先跑n个长度，在启用慢指针，这样快指针到达终点时，与慢指针刚好相差n个长度>>        <br><strong>判断linklist长度是偶数还是奇数：主要看fast，如果fast是None的话，链表的长度是偶数，所以判断的时候用if not    fast : (linklist length example#123456)</strong>      </td></tr><tr><td> <a href="onenote:Data_str\Array_String.one#20. Valid%20Parentheses&amp;section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&amp;page-id={598C4FC1-AD55-41A0-9AFD-6CBF4CA9CDE6}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">20. Valid   Parentheses</a>   <br>使用stack的方式--整理思路可以想象成配对：一对人，在前面的是公头，后面的是母头，可以看出对公头进行存储是value，对母头存储是key，进行查询   <br><code>stack = []<br>store = {')':'(',']':'[','}':'{'}  # 为什么需要这样设计？<br>for char in s:<br>   if char in store.values(): # 将正向的符号使用stack存储起来<br>      stack.append(char)<br>   elif char in store.keys(): # 查找key进行配对<br>      if stack == [] or store[char] != stack.pop():<br>        return False<br>return stack == [] </code></td></tr><tr><td> <a href="onenote:interview_easy.one#21.%C2%A0Merge%20Two%20Sorted%20Lists&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={858F97B4-44A4-452B-A0E2-40BF0204D6CA}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">21. Merge Two Sorted Lists</a>             <br>创造dummy节点用来串接两个链表较大的值/交换头节点              </td></tr><tr><td> <a href="onenote:interview_easy.one#48.%C2%A0Rotate%20Image&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={7DE328BE-581B-4CB4-A111-FB0FCE463440}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">48. Rotate Image</a>  <br>矩阵旋转技巧 * clockwise rotate* first         <br><code> zip(*a)使用<br> >>> a = [[1,2,3],[4,5,6],[7,8,9]]<br> >>> d = zip(*a)<br> >>> next(d)<br> (1, 4, 7)</code></td></tr><tr><td> <a href="onenote:interview_mediun.one#49.%C2%A0Group%20Anagrams&amp;section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&amp;page-id={7BFFFCCE-8ABE-4D7F-BBF4-A8F4C203C349}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">49. Group Anagrams</a> <br>使用的collections.defaultdict函数/sorted()接受迭代对象返回list/对字符出现频率进行统计        <br><code>def groupAnagrams(strs):<br>   ans = collections.defaultdict(list)<br>   for s in strs:<br>     count = [0] * 26<br>     for c in s:<br>       count[ord(c) - ord('a')] += 1<br>       ans[tuple(count)].append(s)<br>     return ans.values() </code></td></tr><tr><td> <a href="onenote:%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84\DP_DC.one#53.%C2%A0Maximum%20Subarray&amp;section-id={157E8CB4-9CAF-4405-98AB-411754D1652A}&amp;page-id={9AD28D37-6B8A-492F-8C98-E025647F855F}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">53. Maximum Subarray</a>             <br>DP动态规划：典型动态规划模板<br> <code>for i in range(1, len(nums)):<br>   if nums[i-1] > 0: # 对前面的每一项之和进行判断，妙呀<br>     nums[i] += nums[i-1]<br>   return max(nums)    </code> </td></tr><tr><td> <a href="onenote:interview_mediun.one#73.%C2%A0Set%20Matrix%20Zeroes&amp;section-id={E91080C2-F7A4-491E-8046-592AF503C9DC}&amp;page-id={1C2577B9-1AD3-442A-B73D-02BCB8B76B15}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">73. Set Matrix Zeroes</a> <br>想法：思想，就是在第一行和第一列设置flag（就是将首先将他们置为0，后来第一行和第一列的值就好了）<br>使用迭代只能对一个list进行置零，要是想给一列置零还需要遍历下标            </td></tr><tr><td> <a href="onenote:Data_str\Sort_and_Search.one#88.%C2%A0Merge%20Sorted%20Array&amp;section-id={0B4DFBAC-DF29-4843-88F3-0BDC6A6E4922}&amp;page-id={8DAD90C3-74DA-4A8C-9656-F28E63655F37}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/leetcoding">88. Merge Sorted Array</a> <br>从list后面开始比较，这样的好处是前面排过序的部分不用反复排序                       </td></tr><tr><td><a href="onenote:Tree\Binary_Tree.one#94.(中序遍历)Inorder%20Traversal&amp;section-id={8330C168-B20E-4ECD-B10F-5DEC923385AA}&amp;page-id={9B0CEE8C-3C1F-454A-AA9D-A10AB5D342D5}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">94.(中序遍历)Inorder Traversal</a><br>其实使用recursion遍历，没有办法中间停止，但是使用iteration可以中间暂停       <br>  <code>def inorderTraversal(self, root):<br>    res = []<br>    if root:<br>       res += self.inorderTraversal(root.left)  <br>       res.append(root.val)<br>       res += self.inorderTraversal(root.right)<br>    return res<br> # iteratively       <br> def inorderTraversal(self, root):<br>     res, stack = [], []<br>     while True:<br>         while root:<br>             stack.append(root)<br>             root = root.left<br>         if not stack:<br>             return res<br>         node = stack.pop()<br>         res.append(node.val)<br>         root = node.right </code></td></tr><tr><td> <a href="onenote:leetcode.one#102.(%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86)Level%20Order%20Traversal&amp;section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&amp;page-id={13B3C18E-0A82-453C-ABFD-3869DABB68F1}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">102.(层级遍历)Level Order Traversal</a>   <br><strong>queue使用/BFS>></strong>      <strong>需要总结：</strong>      </td></tr><tr><td><a href="onenote:leetcode.one#104.%C2%A0Maximum%20Depth%20of%20Binary%20Tree&amp;section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&amp;page-id={62C0D1BB-2FE2-4127-B786-EBD752CEDB66}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">104. Maximum Depth of Binary Tree</a>        <br>初始化定义ans的方式def __init__(self):>>          </td></tr><tr><td> <a href="onenote:Tree\Binary_Tree.one#105.(%E7%94%B1%E5%89%8D%E4%B8%AD%E9%87%8D%E5%BB%BA)%C2%A0Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder&amp;section-id={8330C168-B20E-4ECD-B10F-5DEC923385AA}&amp;page-id={5793F14D-2B4A-40D1-8C73-7F6848A3BE68}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">105.(由前中重建) Construct Binary Tree from Preorder   and Inorder Traversal</a> <br> 105. Construct   Binary Tree from Preorder and Inorder Traversal    <br><code>  def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:<br>     if not preorder or not inorder:<br>         return None<br>     root = TreeNode(preorder.pop(0))<br>     index = inorder.index(root.val)<br>     root.left = self.buildTree(preorder,inorder[: index])<br>     root.right = self.buildTree(preorder , inorder[index+1:])<br>     return root   </code> <br>   </td></tr><tr><td> <a href="onenote:Tree\Binary_Tree.one#116.%C2%A0Populating%20Next%20Right%20Pointers%20in%20Each%20Node%0b117.%C2%A0Populating&amp;section-id={8330C168-B20E-4ECD-B10F-5DEC923385AA}&amp;page-id={350B70CC-E125-418C-A2F9-907F9305B246}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">116. Populating   Next Right Pointers in Each Node</a>   <a href="onenote:Tree\Binary_Tree.one#116.%C2%A0Populating%20Next%20Right%20Pointers%20in%20Each%20Node%0b117.%C2%A0Populating&amp;section-id={8330C168-B20E-4ECD-B10F-5DEC923385AA}&amp;page-id={350B70CC-E125-418C-A2F9-907F9305B246}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">117. Populating Next Right Pointers in Each Node II</a>   <br> 116/117：node添加和检验方式            <br><code>while queue:<br>   cur_level , size = [] ,len(queue)<br>   for i in range(size):<br>     node = queue.popleft()<br>     if node:<br>       queue.append(node.left)<br>       queue.append(node.right)<br>       cur_level.append(node)  # 将每层的node值添加进cur_level<br>     for index,node in enumerate(cur_level[:-1]):<br>       node.next = cur_level[index+1]<br>       cur_level[-1].next = None    </code><br> </td></tr><tr><td> <a href="onenote:interview_easy.one#121\122.%C2%A0Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={84E22D85-C74B-4CEB-94BE-E12C4A87B5A3}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">121/122. Best Time to Buy and Sell Stock II</a> <br>一个点要么是最低点要么是差值最大点,                        </td></tr><tr><td> <a href="onenote:interview_easy.one#136.%C2%A0Single%20Number&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={55D9A7C2-679B-4EDF-A785-432D61B24FF8}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">136. Single Number</a>       <br>异或使用So we can XOR all bits together to find the unique         number.<br>                 a⊕b⊕a=(a⊕a)⊕b=0⊕b=b</td></tr><tr><td> <a href="onenote:leetcode.one#160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8&amp;section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&amp;page-id={A80F61AB-34A7-48AE-A186-EC72B11C8669}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">160. 相交链表</a> <br><code>a = 1 if 0 else 2</code>使用结构>>        逻辑解读：<br>       <code>if 0 : a = 1    else: a =21</code>      </td></tr><tr><td> <a href="https://leetcode.com/problems/rotate-array/">189. Rotate Array</a>  <br>让数字在一定范围内循环递增常常使用  % 操作<br> 注意点：当循环在一个list中，比如list=[1,2,3,4]，当寻找index=5时，希望循环list里面的元素，使用index = index  %  len(list)    <br>来自 &lt;<a href="https://github.com/cy69855522/Shortest-LeetCode-Python-Solutions/blob/master/README.md#-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">https://github.com/cy69855522/Shortest-LeetCode-Python-Solutions/blob/master/README.md#-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE</a>> </td></tr><tr><td> <a href="onenote:leetcode.one#203.%C2%A0Remove%20Linked%20List%20Elements&amp;section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&amp;page-id={D5088368-2685-4015-BE04-8456FCEF504C}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">203. Remove    Linked List Elements</a>  <br>创造dummy节点以满足整体性dummy_head= ListNode(-1)        </td></tr><tr><td> <a href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate</a>        <br>像这一类的重复问题的查找，基本上是有两种思路：--使用hash性质的set/dict，--或者使用异或的数学解决      </td></tr><tr><td> <a href="onenote:interview_easy.one#234.%C2%A0Palindrome%20Linked%20List&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={5B897A85-C29C-4EDE-BDD7-55707F0C7734}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">234. Palindrome Linked List</a>         <br>做法和参考做法其实比较关键的还是reversed  first half 部分不一样，但是微妙之处我还是没有能体会到，但是收获是链表反转                    </td></tr><tr><td> <a href="onenote:interview_easy.one#242.%C2%A0Valid%20Anagram&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={5CA3F973-8350-4DB4-B324-09E666AEBA21}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">242. Valid Anagram</a>   <br>dict统计序列中重复出现频次/使用list统计有限个数出现频次<br><code> for item in s:<br>    dic1[item] = dic1.get(item, 0) + 1</code><br>说明dict.get(item , default =0) 表示如果在字典中查找到item（dic1中的key）返回value，要是没有找到返回default值（为0），实现统计意义      </td></tr><tr><td><a href="onenote:Data_str\Array_String.one#283.%20移动零&amp;section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&amp;page-id={47AA3E93-247F-453F-BECA-AC86CE176950}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">283. 移动零</a><br><a href="https://leetcode.com/problems/move-zeroes/">283.Move Zeroes</a>      <br>交换两个值的时候a，b = b，a      <br>while循环的中断点需要加break                    </td></tr><tr><td><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. Intersection of Two Arrays</a>  <br>set操作时间空间都是O(1)<br>来自 &lt;<a href="https://leetcode.com/problems/intersection-of-two-arrays/solution/">https://leetcode.com/problems/intersection-of-two-arrays/solution/</a>>    <br> <code> To solve the problem in linear time, let's use the structure set, which provides in/contains operation in O(1) time in average case. <br>  list(set2 &amp; set1)查找出公共元素 <br>  list转化为set都需要O(n)的空间 <br>  Complexity Analysis <br> Time complexity : O(n+m), where n and m are arrays' lengths.O(n) time is used to convert nums1into set,O(m) time is used to convert nums2, and contains/in operations are O(1) in the average case.<br> Space complexity : O(m+n) in the worst case when all elements in the arrays are different.  </code></td></tr><tr><td><a href="onenote:interview_easy.one#350.%C2%A0Intersection%20of%20Two%20Arrays%20II&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={776E38D0-E2C1-47AA-BF4B-1D8EA3A2A3AA}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">350. Intersection of Two Arrays II</a>       <br>灵活使用collections.Counter进行对数组的统计        </td></tr><tr><td><a href="onenote:interview_easy.one#387.%C2%A0First%20Unique%20Character%20in%20a%20String&amp;section-id={F8A620DF-0CC1-4E4A-B45B-B116C4C2FCBE}&amp;page-id={DCEBF216-0D4C-4618-BB86-0605BA779CDA}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">387. First Unique Character in a         String</a> <br>dict统计字频使用的是：count = collections.Counter(s)                   </td></tr><tr><td><a href="https://leetcode.com/problems/fizz-buzz/">412.         Fizz Buzz</a><br>>>>来自 &lt;<a href="https://leetcode.com/problems/fizz-buzz/">https://leetcode.com/problems/fizz-buzz/</a>>                 <br>利用字典存储对应的值，但是要想两个字典进行融合输出    fizz_buzz_dict = {3 : "Fizz", 5 : "Buzz"}  >>>想要输出3/5的组合即15 = 3*5使用对字典循环     <br> <br> <code>fizz_buzz_dict = {3 : "Fizz", 5 : "Buzz"}  </code><br><code>>>>想要输出3/5的组合即15 = 3*5使用对字典循环<br> num_ans_str = ""<br>     for key in fizz_buzz_dict.keys():<br>            # If the num is divisible by key,<br>       # then add the corresponding string mapping to current num_ans_str<br>       if num % key == 0:<br>          num_ans_str += fizz_buzz_dict[key]  # 其实这个地方3/5分两部分进行添加 </code></td></tr><tr><td> <a href="onenote:Data_str\Array_String.one#520.%C2%A0Detect%20Capital&amp;section-id={DB60C76D-8D3B-4A5D-AB61-2FAF0910553D}&amp;page-id={C3D8481C-1B74-4F14-B5C0-64C6EDA58ABC}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_1_leetcode">520. Detect Capital</a>   <br>判断单词的大小写<br>  520. Detect Capital<br>     对所有单词判断大写all('A'       &lt;= ch &lt;= 'Z' for ch in word)<br>   对每个单词进行标记   <br><code> c = 0<br>     for i in word:<br>         if i == i.upper():<br>            c += 1<br>     return c == len(word) or (c == 1 and word[0] == word[0].upper()) or c == 0 </code></td></tr><tr><td> <a href="onenote:leetcode.one#590.%C2%A0N-ary%20Tree%20Postorder%20Traversal&amp;section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&amp;page-id={8185AAC5-81FF-47E0-ACDF-5DE3B7632B55}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/%E7%89%9B%E5%AE%A2_offer">590. N-ary Tree    Postorder Traversal</a>       <br><strong>使用and去掉root = None的情况</strong>        <strong>stack = root and [root]>> </strong><br><strong>>></strong><a href="onenote:leetcode.one#700. Search%20in%20a%20Binary%20Search%20Tree&amp;section-id={BFF65B0F-7C52-4A53-88B6-34E63464BA33}&amp;page-id={295CA6D0-329D-4A89-BF02-14CCB888BE7E}&amp;end&amp;base-path=https://d.docs.live.net/f3d60c6c0c0e602f/Notebook/0_day_for_day/牛客_offer">700. Search in    a Binary Search Tree</a>      </td></tr><tr><td>
  &nbsp;
  </td></tr></tbody></table>


<!-- /wp:table -->